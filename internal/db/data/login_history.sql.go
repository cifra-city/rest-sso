// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: login_history.sql

package data

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countFailedLogins = `-- name: CountFailedLogins :one
SELECT COUNT(*) FROM login_history
WHERE user_id = $1 AND success = false
`

func (q *Queries) CountFailedLogins(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFailedLogins, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSuccessfulLogins = `-- name: CountSuccessfulLogins :one
SELECT COUNT(*) FROM login_history
WHERE user_id = $1 AND success = true
`

func (q *Queries) CountSuccessfulLogins(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSuccessfulLogins, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteLoginHistoryByDeviceID = `-- name: DeleteLoginHistoryByDeviceID :exec
DELETE FROM login_history
WHERE device_id = $1
`

func (q *Queries) DeleteLoginHistoryByDeviceID(ctx context.Context, deviceID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteLoginHistoryByDeviceID, deviceID)
	return err
}

const deleteLoginHistoryByUserID = `-- name: DeleteLoginHistoryByUserID :exec
DELETE FROM login_history
WHERE user_id = $1
`

func (q *Queries) DeleteLoginHistoryByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteLoginHistoryByUserID, userID)
	return err
}

const deleteOldLoginHistory = `-- name: DeleteOldLoginHistory :exec
DELETE FROM login_history
WHERE login_time < NOW() - INTERVAL '90 days'
`

func (q *Queries) DeleteOldLoginHistory(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteOldLoginHistory)
	return err
}

const getLoginHistoryByDeviceID = `-- name: GetLoginHistoryByDeviceID :many
SELECT id, user_id, device_id, ip_address, login_time, success, failure_reason FROM login_history
WHERE device_id = $1
ORDER BY login_time DESC
`

func (q *Queries) GetLoginHistoryByDeviceID(ctx context.Context, deviceID uuid.UUID) ([]LoginHistory, error) {
	rows, err := q.db.QueryContext(ctx, getLoginHistoryByDeviceID, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoginHistory
	for rows.Next() {
		var i LoginHistory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.IpAddress,
			&i.LoginTime,
			&i.Success,
			&i.FailureReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginHistoryByUserID = `-- name: GetLoginHistoryByUserID :many
SELECT id, user_id, device_id, ip_address, login_time, success, failure_reason FROM login_history
WHERE user_id = $1
ORDER BY login_time DESC
`

func (q *Queries) GetLoginHistoryByUserID(ctx context.Context, userID uuid.UUID) ([]LoginHistory, error) {
	rows, err := q.db.QueryContext(ctx, getLoginHistoryByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoginHistory
	for rows.Next() {
		var i LoginHistory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.IpAddress,
			&i.LoginTime,
			&i.Success,
			&i.FailureReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentSuccessfulLogins = `-- name: GetRecentSuccessfulLogins :many
SELECT id, user_id, device_id, ip_address, login_time, success, failure_reason FROM login_history
WHERE user_id = $1 AND success = true
ORDER BY login_time DESC
    LIMIT $2
`

type GetRecentSuccessfulLoginsParams struct {
	UserID uuid.UUID
	Limit  int32
}

func (q *Queries) GetRecentSuccessfulLogins(ctx context.Context, arg GetRecentSuccessfulLoginsParams) ([]LoginHistory, error) {
	rows, err := q.db.QueryContext(ctx, getRecentSuccessfulLogins, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoginHistory
	for rows.Next() {
		var i LoginHistory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceID,
			&i.IpAddress,
			&i.LoginTime,
			&i.Success,
			&i.FailureReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithFrequentFailedLogins = `-- name: GetUsersWithFrequentFailedLogins :many
SELECT user_id, COUNT(*) as failure_count
FROM login_history
WHERE success = false
GROUP BY user_id
HAVING COUNT(*) > $1
ORDER BY failure_count DESC
`

type GetUsersWithFrequentFailedLoginsRow struct {
	UserID       uuid.UUID
	FailureCount int64
}

func (q *Queries) GetUsersWithFrequentFailedLogins(ctx context.Context, dollar_1 interface{}) ([]GetUsersWithFrequentFailedLoginsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersWithFrequentFailedLogins, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithFrequentFailedLoginsRow
	for rows.Next() {
		var i GetUsersWithFrequentFailedLoginsRow
		if err := rows.Scan(&i.UserID, &i.FailureCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertLoginHistory = `-- name: InsertLoginHistory :exec
INSERT INTO login_history (id, user_id, device_id, ip_address, login_time, success, failure_reason)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type InsertLoginHistoryParams struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	DeviceID      uuid.UUID
	IpAddress     string
	LoginTime     time.Time
	Success       bool
	FailureReason NullFailureReason
}

func (q *Queries) InsertLoginHistory(ctx context.Context, arg InsertLoginHistoryParams) error {
	_, err := q.db.ExecContext(ctx, insertLoginHistory,
		arg.ID,
		arg.UserID,
		arg.DeviceID,
		arg.IpAddress,
		arg.LoginTime,
		arg.Success,
		arg.FailureReason,
	)
	return err
}
